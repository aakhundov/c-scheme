; library functions

(define (caar x) (car (car x)))
(define (cadr x) (car (cdr x)))
(define (cdar x) (cdr (car x)))
(define (cddr x) (cdr (cdr x)))

(define (caaar x) (car (car (car x))))
(define (caadr x) (car (car (cdr x))))
(define (cadar x) (car (cdr (car x))))
(define (caddr x) (car (cdr (cdr x))))
(define (cdaar x) (cdr (car (car x))))
(define (cdadr x) (cdr (car (cdr x))))
(define (cddar x) (cdr (cdr (car x))))
(define (cdddr x) (cdr (cdr (cdr x))))

(define (caaaar x) (car (car (car (car x)))))
(define (caaadr x) (car (car (car (cdr x)))))
(define (caadar x) (car (car (cdr (car x)))))
(define (caaddr x) (car (car (cdr (cdr x)))))
(define (cadaar x) (car (cdr (car (car x)))))
(define (cadadr x) (car (cdr (car (cdr x)))))
(define (caddar x) (car (cdr (cdr (car x)))))
(define (cadddr x) (car (cdr (cdr (cdr x)))))
(define (cdaaar x) (cdr (car (car (car x)))))
(define (cdaadr x) (cdr (car (car (cdr x)))))
(define (cdadar x) (cdr (car (cdr (car x)))))
(define (cdaddr x) (cdr (car (cdr (cdr x)))))
(define (cddaar x) (cdr (cdr (car (car x)))))
(define (cddadr x) (cdr (cdr (car (cdr x)))))
(define (cdddar x) (cdr (cdr (cdr (car x)))))
(define (cddddr x) (cdr (cdr (cdr (cdr x)))))

(define (first x) (car x))
(define (second x) (car (cdr x)))
(define (third x) (car (cdr (cdr x))))
(define (fourth x) (car (cdr (cdr (cdr x)))))
(define (fifth x) (car (cdr (cdr (cdr (cdr x))))))
(define (sixth x) (car (cdr (cdr (cdr (cdr (cdr x)))))))
(define (seventh x) (car (cdr (cdr (cdr (cdr (cdr (cdr x))))))))
(define (eighth x) (car (cdr (cdr (cdr (cdr (cdr (cdr (cdr x)))))))))
(define (ninth x) (car (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr x))))))))))
(define (tenth x) (car (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr (cdr x)))))))))))

(define (list-ref n lst)
  (cond ((null? lst) '())
        ((= n 0) (car lst))
        (else (list-ref (- n 1) (cdr lst)))))

(define (map f lst)
  (if (null? lst)
      '()
      (cons (f (car lst))
            (map f (cdr lst)))))

; diagnostics tools

(define (assert-equal expression expected)
  (let ((result (eval expression)))
    (cond ((equal? result expected)
           (info "%s == %s" expression result))  ; exactly equals
          ((and (number? expected)
                (number? result)
                (< (abs (- result expected)) 1e-4))
           (info "%s ~= %s" expression result))  ; approximately equals
          (else (error "%s != %s, but %s" expression expected result)))))

(define (measure expression)
  (let ((start (time)))
    (begin (eval expression)
           (info "%s took %s seconds" expression (- (time) start)))))

; unit test

(assert-equal '(caar '((1 2) 3 4)) 1)
(assert-equal '(cadr '((1 2) 3 4)) 3)
(assert-equal '(cdar '((1 2) 3 4)) '(2))
(assert-equal '(cddr '((1 2) 3 4)) '(4))

(assert-equal '(caaar '(((1 2) 3 4) (5 6) 7)) 1)
(assert-equal '(caadr '(((1 2) 3 4) (5 6) 7)) 5)
(assert-equal '(cadar '(((1 2) 3 4) (5 6) 7)) 3)
(assert-equal '(caddr '(((1 2) 3 4) (5 6) 7)) 7)
(assert-equal '(cdaar '(((1 2) 3 4) (5 6) 7)) '(2))
(assert-equal '(cdadr '(((1 2) 3 4) (5 6) 7)) '(6))
(assert-equal '(cddar '(((1 2) 3 4) (5 6) 7)) '(4))
(assert-equal '(cdddr '(((1 2) 3 4) (5 6) 7)) '())

(assert-equal '(first '(1 2 3 4 5 6 7 8 9 10)) 1)
(assert-equal '(second '(1 2 3 4 5 6 7 8 9 10)) 2)
(assert-equal '(third '(1 2 3 4 5 6 7 8 9 10)) 3)
(assert-equal '(fourth '(1 2 3 4 5 6 7 8 9 10)) 4)
(assert-equal '(fifth '(1 2 3 4 5 6 7 8 9 10)) 5)
(assert-equal '(sixth '(1 2 3 4 5 6 7 8 9 10)) 6)
(assert-equal '(seventh '(1 2 3 4 5 6 7 8 9 10)) 7)
(assert-equal '(eighth '(1 2 3 4 5 6 7 8 9 10)) 8)
(assert-equal '(ninth '(1 2 3 4 5 6 7 8 9 10)) 9)
(assert-equal '(tenth '(1 2 3 4 5 6 7 8 9 10)) 10)

(assert-equal '(list-ref 0 '(1 2 3 4 5)) 1)
(assert-equal '(list-ref 4 '(1 2 3 4 5)) 5)
(assert-equal '(list-ref 5 '(1 2 3 4 5)) '())

(assert-equal '(map - '(1 2 3)) '(-1 -2 -3))
(assert-equal '(map car '((1 1) (2 2) (3 3))) '(1 2 3))
(assert-equal '(map cdr '((1 1) (2 2) (3 3))) '((1) (2) (3)))
(assert-equal '(map + '()) '())
